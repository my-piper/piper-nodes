<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Composer</title>
  </head>
  <body class="m-0 font-sans h-screen select-none bg-graphite-600 text-white">
    <!-- Tailwind CSS compiled -->
    <link rel="stylesheet" href="../../../styles/ui.css" />

    <!-- Vue.js -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

    <style>
      /* Canvas-specific patterns and guides that can't be done with Tailwind */
      .canvas-background {
        background-color: #111111; /* graphite-600 */
        background-image:
          linear-gradient(45deg, #333 25%, transparent 25%),
          linear-gradient(-45deg, #333 25%, transparent 25%),
          linear-gradient(45deg, transparent 75%, #333 75%),
          linear-gradient(-45deg, transparent 75%, #333 75%);
        background-size: 20px 20px;
        background-position:
          0 0,
          0 10px,
          10px -10px,
          -10px 0px;
        background-repeat: repeat;
      }

      .vertical-guide::after,
      .horizontal-guide::after {
        position: absolute;
        background: rgba(0, 209, 209, 0.9); /* primary/90 */
        color: white;
        padding: 2px 6px;
        font-size: 12px;
        border-radius: 4px;
        white-space: nowrap;
      }

      .vertical-guide::after {
        content: attr(data-width) "px";
        top: 10px;
        left: 5px;
      }

      .horizontal-guide::after {
        content: attr(data-height) "px";
        top: 5px;
        left: 10px;
      }
    </style>

    <script type="text/x-template" id="app-tpl">
      <div class="relative w-[4000px] h-[4000px] bg-graphite-500 overflow-hidden" ref="canvas">
        <div
          class="canvas-background absolute top-0 left-0 border border-graphite-300"
          :style="{
            width: canvasWidth + 'px',
            height: canvasHeight + 'px'
          }"
        ></div>
        <div
          class="vertical-guide absolute top-0 bottom-0 w-0.5 bg-primary cursor-ew-resize z-10 hover:w-[3px] hover:bg-primary"
          :style="{ left: canvasWidth + 'px' }"
          :data-width="canvasWidth"
          @mousedown="startGuideResize"
        ></div>
        <div
          class="horizontal-guide absolute left-0 right-0 h-0.5 bg-primary cursor-ns-resize z-10 hover:h-[3px] hover:bg-primary"
          :style="{ top: canvasHeight + 'px' }"
          :data-height="canvasHeight"
          @mousedown="startHorizontalGuideResize"
        ></div>
        <div
          v-for="(layer, layerId) in layers"
          :key="layerId"
          :style="{
            position: 'absolute',
            left: layer.x + 'px',
            top: layer.y + 'px',
            zIndex: layer.order || 0,
            ...(layer.type === 'image' ? {
                width: layer.width + 'px',
                height: layer.height + 'px'
            } : {})
          }"
          class="opacity-80 hover:opacity-100"
          @mousedown="startDrag($event, layerId)"
        >
          <img
            v-if="layer.type === 'image'"
            :src="inputs[layerId]"
            class="w-full h-full"
            draggable="false"
          />
          <div
            v-if="layer.type === 'text'"
            class="whitespace-nowrap"
            :style="{
              fontSize: layer.fontSize + 'px',
              color: layer.color,
              fontFamily: layer.fontFamily,
              fontWeight: layer.fontWeight,
              backgroundColor: layer.backgroundColor
            }"
          >
            {{ inputs[layerId] }}
          </div>
          <div
            v-if="layer.type === 'image'"
            class="absolute -bottom-1.5 -right-1.5 w-3 h-3 bg-primary cursor-se-resize rounded-sm opacity-80 hover:opacity-100 hover:scale-110 transition-transform"
            @mousedown.stop="startResize($event, layerId)"
          ></div>
          <div
            v-if="DEBUG"
            class="absolute -top-1.5 -right-1.5 bg-black/70 text-white px-1 py-0.5 text-[10px] rounded-bl opacity-0 transition-opacity"
            :class="{ 'opacity-100': isDragging && layerId === Object.keys(layers).length - 1 }"
          >
            {{ layer.x }}, {{ layer.y }}
            <span v-if="layer.type === 'image'">
              | {{ layer.width }} x {{ layer.height }}</span
            >
          </div>
        </div>
      </div>
      <div
        v-if="selectedLayer && selectedLayer.type === 'image'"
        class="fixed top-5 right-5 z-[30] bg-graphite-600 text-white p-5 rounded-md border border-graphite-300 min-w-[200px] space-y-4"
      >
        <label class="flex flex-col gap-1.5 text-sm">
          Left:
          <input
            type="number"
            v-model.number="selectedLayer.x"
            step="1"
            class="px-3 py-2 bg-graphite-500 text-white border border-graphite-200 rounded focus:bg-graphite-400 focus:border-graphite-100 focus:outline-none"
          />
        </label>
        <label class="flex flex-col gap-1.5 text-sm">
          Top:
          <input
            type="number"
            v-model.number="selectedLayer.y"
            step="1"
            class="px-3 py-2 bg-graphite-500 text-white border border-graphite-200 rounded focus:bg-graphite-400 focus:border-graphite-100 focus:outline-none"
          />
        </label>
        <label class="flex flex-col gap-1.5 text-sm">
          Width:
          <input
            type="number"
            v-model.number="selectedLayer.width"
            min="1"
            step="1"
            @input="maintainAspectRatio('width')"
            class="px-3 py-2 bg-graphite-500 text-white border border-graphite-200 rounded focus:bg-graphite-400 focus:border-graphite-100 focus:outline-none"
          />
        </label>
        <label class="flex flex-col gap-1.5 text-sm">
          Height:
          <input
            type="number"
            v-model.number="selectedLayer.height"
            min="1"
            step="1"
            @input="maintainAspectRatio('height')"
            class="px-3 py-2 bg-graphite-500 text-white border border-graphite-200 rounded focus:bg-graphite-400 focus:border-graphite-100 focus:outline-none"
          />
        </label>
        <button
          @click="resetImageDimensions"
          class="px-2 py-1.5 bg-graphite-400 text-white border border-graphite-200 rounded hover:bg-graphite-300 hover:border-graphite-100 transition-colors text-xs"
        >
          Reset
        </button>
        <label class="flex items-center gap-2 text-sm cursor-pointer">
          <input
            type="checkbox"
            v-model="maintainAspect"
          />
          Save aspect ratio
        </label>
        <label class="flex flex-col gap-1.5 text-sm">
          Order (z-index):
          <input
            type="number"
            v-model.number="selectedLayer.order"
            min="0"
            step="1"
            class="px-3 py-2 bg-graphite-500 text-white border border-graphite-200 rounded focus:bg-graphite-400 focus:border-graphite-100 focus:outline-none"
          />
        </label>
      </div>
      <div
        v-if="selectedLayer && selectedLayer.type === 'text'"
        class="fixed top-5 right-5 z-[30] bg-graphite-600 text-white p-5 rounded-md border border-graphite-300 min-w-[200px] space-y-4"
      >
        <label class="flex flex-col gap-1.5 text-sm">
          Font size:
          <input
            type="range"
            v-model="selectedLayer.fontSize"
            min="12"
            max="72"
            step="1"
          />
          <span class="text-xs text-graphite-75">{{ selectedLayer.fontSize }}px</span>
        </label>
        <label class="flex flex-col gap-1.5 text-sm">
          Font Family:
          <select
            v-model="selectedLayer.fontFamily"
            class="px-3 py-2 bg-graphite-500 text-white border border-graphite-200 rounded focus:bg-graphite-400 focus:border-graphite-100 focus:outline-none"
          >
            <option value="Arial, sans-serif">Arial</option>
            <option value="Georgia, serif">Georgia</option>
            <option value="'Times New Roman', serif">Times New Roman</option>
            <option value="'Courier New', monospace">Courier New</option>
            <option value="Helvetica, sans-serif">Helvetica</option>
            <option value="Verdana, sans-serif">Verdana</option>
            <option value="'Comic Sans MS', cursive">Comic Sans MS</option>
            <option value="Impact, sans-serif">Impact</option>
          </select>
        </label>
        <label class="flex flex-col gap-1.5 text-sm">
          Font weight:
          <select
            v-model="selectedLayer.fontWeight"
            class="px-3 py-2 bg-graphite-500 text-white border border-graphite-200 rounded focus:bg-graphite-400 focus:border-graphite-100 focus:outline-none"
          >
            <option value="normal">Normal</option>
            <option value="bold">Bold</option>
          </select>
        </label>
        <label class="flex flex-col gap-1.5 text-sm">
          Text color:
          <input
            type="color"
            v-model="selectedLayer.color"
            class="w-full h-10 border-none rounded cursor-pointer"
          />
        </label>
        <label class="flex flex-col gap-1.5 text-sm">
          Background:
          <div class="flex gap-2">
            <input
              type="color"
              v-model="selectedLayer.backgroundColor"
              class="flex-1 h-10 border-none rounded cursor-pointer"
            />
            <button
              @click="selectedLayer.backgroundColor = 'transparent'"
              class="px-3 py-2 bg-graphite-400 text-white border border-graphite-200 rounded hover:bg-graphite-300 hover:border-graphite-100 transition-colors"
            >
              Reset
            </button>
          </div>
        </label>
        <label class="flex flex-col gap-1.5 text-sm">
          Order (z-index):
          <input
            type="number"
            v-model.number="selectedLayer.order"
            min="0"
            step="1"
            class="px-3 py-2 bg-graphite-500 text-white border border-graphite-200 rounded focus:bg-graphite-400 focus:border-graphite-100 focus:outline-none"
          />
        </label>
      </div>
    </script>

    <div id="app">
      <Suspense>
        <App />
        <template #fallback>
          <div>Loading...</div>
        </template>
      </Suspense>
    </div>

    <script setup type="module">
      const piper = window.Piper?.create() || {
        appRoot: document,
        meta: {
          node: {
            inputs: {
              image1: { type: "image" },
              image2: { type: "image" },
              text1: { type: "string" },
              config: { type: "json" },
            },
          },
        },
        inputs: {
          image1: "https://picsum.photos/150/100",
          image2: "https://picsum.photos/120/120",
          text1: "Hello World",
          config:
            localStorage.getItem("composer") ||
            JSON.stringify({
              canvas: { width: 800, height: 600 },
              layers: {
                image1: {
                  type: "image",
                  x: 50,
                  y: 50,
                  width: 150,
                  height: 100,
                  order: 0,
                },
              },
            }),
        },
        save({ config }) {
          localStorage.setItem("composer", config);
        },
      };

      async function loadImage(url) {
        const img = new Image();
        const loaded = new Promise((resolve, reject) => {
          img.onload = () =>
            resolve({ width: img.naturalWidth, height: img.naturalHeight });
          img.onerror = reject;
        });

        img.src = url;
        return loaded;
      }

      const { defineComponent, ref, reactive, watch, createApp } = Vue;

      const App = defineComponent({
        template: piper.appRoot.querySelector("#app-tpl").textContent,
        async setup() {
          const DEBUG = true;
          const canvas = ref(null);
          const isDragging = ref(false);
          const isResizing = ref(false);
          const dragIndex = ref(-1);
          const resizeIndex = ref(-1);
          const dragOffset = reactive({ x: 0, y: 0 });
          const resizeStart = reactive({ x: 0, y: 0, width: 0, height: 0 });
          const selectedLayer = ref(null);
          const maintainAspect = ref(true);
          const originalAspectRatio = ref(1);

          const maintainAspectRatio = (changedDimension) => {
            if (!maintainAspect.value || !selectedLayer.value) return;

            if (changedDimension === "width") {
              selectedLayer.value.height = Math.floor(
                selectedLayer.value.width / originalAspectRatio.value
              );
            } else if (changedDimension === "height") {
              selectedLayer.value.width = Math.floor(
                selectedLayer.value.height * originalAspectRatio.value
              );
            }
          };

          const inputs = reactive(
            (() => {
              const { meta } = piper;
              const inputs = {};
              for (const [key, input] of Object.entries(meta.node.inputs)) {
                const value = piper.inputs[key];
                if (!!value && ["string", "image"].includes(input.type)) {
                  inputs[key] = piper.inputs[key];
                }
              }
              return inputs;
            })()
          );

          const config = reactive(
            await (async () => {
              const { meta, inputs } = piper;
              const config = !!inputs.config
                ? JSON.parse(inputs.config)
                : {
                    layers: {},
                    canvas: { width: 800, height: 600 },
                  };
              for (const [key, value] of Object.entries(meta.node.inputs)) {
                if (!!config.layers[key]) {
                  continue;
                }
                switch (value.type) {
                  case "string":
                    config.layers[key] = {
                      type: "text",
                      x: 0,
                      y: 0,
                      fontSize: 24,
                      color: "#000000",
                      fontFamily: "Arial, sans-serif",
                      fontWeight: "normal",
                      backgroundColor: "transparent",
                      order: 0,
                    };
                    break;
                  case "image":
                    const url = piper.inputs[key];
                    const { width, height } = await loadImage(url);
                    config.layers[key] = {
                      type: "image",
                      x: 50,
                      y: 50,
                      width,
                      height,
                      originalWidth: width,
                      originalHeight: height,
                      order: 0,
                    };
                    break;
                }
              }
              return config;
            })()
          );

          const canvasWidth = ref(config.canvas.width);
          const canvasHeight = ref(config.canvas.height);
          const layers = reactive(config.layers);

          const saveConfig = () => {
            const config = JSON.stringify(
              {
                canvas: {
                  width: canvasWidth.value,
                  height: canvasHeight.value,
                },
                layers,
              },
              null,
              "\t"
            );
            piper.save({ config });
          };

          watch([canvasWidth, canvasHeight, layers], saveConfig, {
            deep: true,
          });

          const startGuideResize = (event) => {
            const onMouseMove = (e) => {
              const rect = canvas.value.getBoundingClientRect();
              const newWidth = Math.max(
                200,
                Math.min(e.clientX - rect.left, window.innerWidth - 50)
              );
              canvasWidth.value = newWidth;
            };

            const onMouseUp = () => {
              document.removeEventListener("mousemove", onMouseMove);
              document.removeEventListener("mouseup", onMouseUp);
            };

            document.addEventListener("mousemove", onMouseMove);
            document.addEventListener("mouseup", onMouseUp);
          };

          const startHorizontalGuideResize = (event) => {
            const onMouseMove = (e) => {
              const rect = canvas.value.getBoundingClientRect();
              const newHeight = Math.max(200, e.clientY - rect.top);
              canvasHeight.value = newHeight;
            };

            const onMouseUp = () => {
              document.removeEventListener("mousemove", onMouseMove);
              document.removeEventListener("mouseup", onMouseUp);
            };

            document.addEventListener("mousemove", onMouseMove);
            document.addEventListener("mouseup", onMouseUp);
          };

          const startDrag = (event, layerId) => {
            isDragging.value = true;
            dragIndex.value = layerId;
            selectedLayer.value = layers[layerId];

            // Store original aspect ratio when selecting an image layer
            if (selectedLayer.value.type === "image") {
              originalAspectRatio.value =
                selectedLayer.value.width / selectedLayer.value.height;
            }

            const rect = canvas.value.getBoundingClientRect();
            dragOffset.x = event.clientX - rect.left - layers[layerId].x;
            dragOffset.y = event.clientY - rect.top - layers[layerId].y;

            document.addEventListener("mousemove", onMouseMove);
            document.addEventListener("mouseup", stopDrag);
          };

          const startResize = (event, layerId) => {
            isResizing.value = true;
            resizeIndex.value = layerId;

            const rect = canvas.value.getBoundingClientRect();
            resizeStart.x = event.clientX - rect.left;
            resizeStart.y = event.clientY - rect.top;
            resizeStart.width = layers[layerId].width;
            resizeStart.height = layers[layerId].height;

            document.addEventListener("mousemove", onResizeMove);
            document.addEventListener("mouseup", stopResize);
          };

          const onMouseMove = (event) => {
            if (isDragging.value) {
              const rect = canvas.value.getBoundingClientRect();
              const newX = Math.floor(event.clientX - rect.left - dragOffset.x);
              const newY = Math.floor(event.clientY - rect.top - dragOffset.y);

              const layer = layers[dragIndex.value];

              // No limitations - layers can be moved anywhere
              layer.x = newX;
              layer.y = newY;
            }
          };

          const onResizeMove = (event) => {
            if (!isResizing.value) return;

            const rect = canvas.value.getBoundingClientRect();
            const currentX = event.clientX - rect.left;
            const currentY = event.clientY - rect.top;

            const layer = layers[resizeIndex.value];

            if (layer.type === "image") {
              const aspectRatio = resizeStart.width / resizeStart.height;
              const deltaX = currentX - resizeStart.x;
              const deltaY = currentY - resizeStart.y;
              const delta = Math.max(deltaX, deltaY);

              const newWidth = Math.max(
                10,
                Math.floor(resizeStart.width + delta)
              );
              const newHeight = Math.max(
                10,
                Math.floor(newWidth / aspectRatio)
              );

              // No limitations - can resize to any size
              layer.width = newWidth;
              layer.height = newHeight;
            }
          };

          const stopDrag = () => {
            isDragging.value = false;
            dragIndex.value = -1;
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", stopDrag);
          };

          const stopResize = () => {
            isResizing.value = false;
            resizeIndex.value = -1;
            document.removeEventListener("mousemove", onResizeMove);
            document.removeEventListener("mouseup", stopResize);
          };

          const selectLayer = (index) => {
            selectedLayer.value = layers[index];
          };

          const resetImageDimensions = async () => {
            if (!selectedLayer.value || selectedLayer.value.type !== "image") {
              return;
            }

            // Find the layer key to get the image URL
            const layerKey = Object.keys(layers).find(
              (key) => layers[key] === selectedLayer.value
            );
            if (!layerKey || !inputs[layerKey]) {
              return;
            }

            // Load the image to get real dimensions
            const { width, height } = await loadImage(inputs[layerKey]);
            selectedLayer.value.width = width;
            selectedLayer.value.height = height;
            selectedLayer.value.originalWidth = width;
            selectedLayer.value.originalHeight = height;
            originalAspectRatio.value = width / height;
          };

          return {
            DEBUG,
            canvas,
            inputs,
            layers,
            selectedLayer,
            isDragging,
            dragIndex,
            canvasWidth,
            canvasHeight,
            maintainAspect,
            maintainAspectRatio,
            startDrag,
            startResize,
            startGuideResize,
            startHorizontalGuideResize,
            selectLayer,
            resetImageDimensions,
          };
        },
      });

      createApp({
        components: { App },
      }).mount(piper.appRoot.querySelector("#app"));
    </script>
  </body>
</html>
