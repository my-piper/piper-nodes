<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Composer</title>
  </head>
  <body data-theme="dark">
    <link
      rel="stylesheet"
      href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/@picocss/pico@latest/css/pico.colors.min.css"
    />
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
      :root {
        /* compact typography */
        --pico-font-size: 0.875rem; /* ~14px */
        --pico-line-height: 1.3;

        /* smaller inputs/selects/textareas/buttons */
        --pico-form-element-spacing-vertical: 0.35rem;
        --pico-form-element-spacing-horizontal: 0.6rem;

        /* tighter look */
        --pico-radius: 6px; /* try 4px for extra-compact */
        --pico-border-width: 1px;

        /* optional: reduce general gaps a bit */
        --pico-spacing: 0.75rem;

        /* Custom button background */
        --pico-primary-background: #222222;
        
      }

      [data-theme=dark] {
        --canvas-bg: #1a1a1a;
        --canvas-pattern: #333;
        --sidebar-bg: #2a2a2a;
        --layer-border: #555;
        --layer-border-hover: #007bff;
        --pico-border-radius: 4px;
        --pico-card-background-color: #0E0E13;
        --pico-primary-background: #222222;
        --pico-primary-hover-background: #303030;
      }

      body {
        margin: 0;
        font-family: Arial, sans-serif;
        height: 100vh;
        user-select: none;
        background-color: var(--pico-background-color);
        color: var(--pico-color);
      }
      .canvas-container {
        position: relative;
        width: 4000px;
        height: 4000px;
        background: var(--canvas-bg, #1a1a1a);
        overflow: hidden;
      }
      .canvas-background {
        position: absolute;
        top: 0;
        left: 0;
        background-color: var(--pico-card-background-color);
        background-image: linear-gradient(45deg, var(--canvas-pattern, #333) 25%, transparent 25%),
          linear-gradient(-45deg, var(--canvas-pattern, #333) 25%, transparent 25%),
          linear-gradient(45deg, transparent 75%, var(--canvas-pattern, #333) 75%),
          linear-gradient(-45deg, transparent 75%, var(--canvas-pattern, #333) 75%);
        background-size: 20px 20px;
        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        background-repeat: repeat;
        border: 1px solid var(--pico-muted-border-color);
      }

      .layer {
        z-index: 2;
        opacity: 0.8;
      }

      .layer:hover {
        opacity: 1;
      }

      .position {
        position: absolute;
        top: -6px;
        right: -6px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 2px 4px;
        font-size: 10px;
        border-radius: 0 0 0 4px;
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      .position.dragging {
        opacity: 1;
      }
      .resize-handle {
        position: absolute;
        bottom: -6px;
        right: -6px;
        width: 12px;
        height: 12px;
        background: #007bff;
        cursor: se-resize;
        border-radius: 2px;
        opacity: 0.8;
      }

      .resize-handle:hover {
        opacity: 1;
        transform: scale(1.1);
        background: #0056b3;
      }
      .sidebar {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 30;
        background: var(--pico-card-background-color);
        color: var(--pico-color);
        padding: 20px;
        border-radius: var(--pico-border-radius);
        box-shadow: var(--pico-card-box-shadow);
        border: 1px solid var(--pico-muted-border-color);
        min-width: 200px;
      }

      .sidebar h3 {
        margin: 0 0 15px 0;
        font-size: 16px;
      }

      .sidebar label.input {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .sidebar input[type="range"] {
        width: 100%;
      }

      .sidebar span {
        font-size: 12px;
        color: #666;
      }
      .sidebar input[type="color"] {
        width: 100%;
        height: 40px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      .vertical-guide {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 2px;
        background: #007bff;
        cursor: ew-resize;
        z-index: 10;
      }

      .vertical-guide:hover {
        background: #0056b3;
        width: 3px;
      }

      .vertical-guide::after {
        content: attr(data-width) "px";
        position: absolute;
        top: 10px;
        left: 5px;
        background: rgba(0, 123, 255, 0.9);
        color: white;
        padding: 2px 6px;
        font-size: 12px;
        border-radius: 3px;
        white-space: nowrap;
      }

      .horizontal-guide {
        position: absolute;
        left: 0;
        right: 0;
        height: 2px;
        background: #007bff;
        cursor: ns-resize;
        z-index: 10;
      }

      .horizontal-guide:hover {
        background: #0056b3;
        height: 3px;
      }

      .horizontal-guide::after {
        content: attr(data-height) "px";
        position: absolute;
        top: 5px;
        left: 10px;
        background: rgba(0, 123, 255, 0.9);
        color: white;
        padding: 2px 6px;
        font-size: 12px;
        border-radius: 3px;
        white-space: nowrap;
      }
    </style>

    <script type="text/x-template" id="app-tpl">
            <div class="canvas-container" ref="canvas">
        <div
          class="canvas-background"
          :style="{
            width: canvasWidth + 'px',
            height: canvasHeight + 'px'
          }"
        ></div>
        <div
          class="vertical-guide"
          :style="{ left: canvasWidth + 'px' }"
          :data-width="canvasWidth"
          @mousedown="startGuideResize"
        ></div>
        <div
          class="horizontal-guide"
          :style="{ top: canvasHeight + 'px' }"
          :data-height="canvasHeight"
          @mousedown="startHorizontalGuideResize"
        ></div>
        <div
          v-for="(layer, layerId) in layers"
          :key="layerId"
          :style="{
            position: 'absolute',
            left: layer.x + 'px',
            top: layer.y + 'px',
            zIndex: layer.order || 0,
            ...(layer.type === 'image' ? {
                width: layer.width + 'px',
                height: layer.height + 'px'
            } : {})
          }"
          class="layer"
          @mousedown="startDrag($event, layerId)"
        >
          <img
            v-if="layer.type === 'image'"
            :src="inputs[layerId]"
            :style="{
              width: '100%',
              height: '100%'
            }"
            draggable="false"
          />
          <div
            v-if="layer.type === 'text'"
            :style="{
              fontSize: layer.fontSize + 'px',
              color: layer.color,
              fontFamily: layer.fontFamily,
              fontWeight: layer.fontWeight,
              backgroundColor: layer.backgroundColor,
              whiteSpace: 'nowrap'
            }"
          >
            {{ inputs[layerId] }}
          </div>
          <div
            v-if="layer.type === 'image'"
            class="resize-handle"
            @mousedown.stop="startResize($event, layerId)"
          ></div>
          <div
            v-if="DEBUG"
            class="position"
            :class="{ dragging: isDragging && layerId === Object.keys(layers).length - 1 }"
          >
            {{ layer.x }}, {{ layer.y }}
            <span v-if="layer.type === 'image'">
              | {{ layer.width }} x {{ layer.height }}</span
            >
          </div>
        </div>
      </div>
      <div
        v-if="selectedLayer && selectedLayer.type === 'image'"
        class="sidebar"
      >
        <label class="input">
          Left:
          <input
            type="number"
            v-model.number="selectedLayer.x"
            step="1"
          />
        </label>
        <label class="input">
          Top:
          <input
            type="number"
            v-model.number="selectedLayer.y"
            step="1"
          />
        </label>
        <label class="input">
          Width:
          <input
            type="number"
            v-model.number="selectedLayer.width"
            min="1"
            step="1"
            @input="maintainAspectRatio('width')"
          />
        </label>
        <label class="input">
          Height:
          <input
            type="number"
            v-model.number="selectedLayer.height"
            min="1"
            step="1"
            @input="maintainAspectRatio('height')"
          />
        </label>
        <label>
          <input
            type="checkbox"
            v-model="maintainAspect"
          />
          Save aspect ratio
        </label>
        <label class="input">
          Order (z-index):
          <input
            type="number"
            v-model.number="selectedLayer.order"
            min="0"
            step="1"
          />
        </label>
      </div>
      <div
        v-if="selectedLayer && selectedLayer.type === 'text'"
        class="sidebar"
      >
        <label>
          Font size:
          <input
            type="range"
            v-model="selectedLayer.fontSize"
            min="12"
            max="72"
            step="1"
          />
          <span>{{ selectedLayer.fontSize }}px</span>
        </label>
        <label>
          Font Family:
          <select v-model="selectedLayer.fontFamily">
            <option value="Arial, sans-serif">Arial</option>
            <option value="Georgia, serif">Georgia</option>
            <option value="'Times New Roman', serif">Times New Roman</option>
            <option value="'Courier New', monospace">Courier New</option>
            <option value="Helvetica, sans-serif">Helvetica</option>
            <option value="Verdana, sans-serif">Verdana</option>
            <option value="'Comic Sans MS', cursive">Comic Sans MS</option>
            <option value="Impact, sans-serif">Impact</option>
          </select>
        </label>
        <label>
          Font weight:
          <select v-model="selectedLayer.fontWeight">
            <option value="normal">Normal</option>
            <option value="bold">Bold</option>
          </select>
        </label>
        <label>
          Text color:
          <input type="color" v-model="selectedLayer.color" />
        </label>
        <label>
          Background:
          <div class="color-input-group">
            <input type="color" v-model="selectedLayer.backgroundColor" />
            <button @click="selectedLayer.backgroundColor = 'transparent'">
              Reset
            </button>
          </div>
        </label>
        <label class="input">
          Order (z-index):
          <input
            type="number"
            v-model.number="selectedLayer.order"
            min="0"
            step="1"
          />
        </label>
      </div>
    </script>

    <div id="app">
      <Suspense>
        <App />
        <template #fallback>
          <div>Loading...</div>
        </template>
      </Suspense>
    </div>

    <script setup type="module">
      const piper = window.Piper?.create() || {
        appRoot: document,
        meta: {
          node: {
            inputs: {
              image1: { type: "image" },
              image2: { type: "image" },
              text1: { type: "string" },
              config: { type: "json" },
            },
          },
        },
        inputs: {
          image1: "https://picsum.photos/150/100",
          image2: "https://picsum.photos/120/120",
          text1: "Hello World",
          config:
            localStorage.getItem("composer") ||
            JSON.stringify({
              canvas: { width: 800, height: 600 },
              layers: {
                image1: {
                  type: "image",
                  x: 50,
                  y: 50,
                  width: 150,
                  height: 100,
                  order: 0,
                },
              },
            }),
        },
        save({ config }) {
          localStorage.setItem("composer", config);
        },
      };

      async function loadImage(url) {
        const img = new Image();
        const loaded = new Promise((resolve, reject) => {
          img.onload = () =>
            resolve({ width: img.naturalWidth, height: img.naturalHeight });
          img.onerror = reject;
        });

        img.src = url;
        return loaded;
      }

      const { defineComponent, ref, reactive, watch, createApp } = Vue;

      const App = defineComponent({
        template: piper.appRoot.querySelector("#app-tpl").textContent,
        async setup() {
          const DEBUG = true;
          const canvas = ref(null);
          const isDragging = ref(false);
          const isResizing = ref(false);
          const dragIndex = ref(-1);
          const resizeIndex = ref(-1);
          const dragOffset = reactive({ x: 0, y: 0 });
          const resizeStart = reactive({ x: 0, y: 0, width: 0, height: 0 });
          const selectedLayer = ref(null);
          const maintainAspect = ref(true);
          const originalAspectRatio = ref(1);

          const maintainAspectRatio = (changedDimension) => {
            if (!maintainAspect.value || !selectedLayer.value) return;

            if (changedDimension === "width") {
              selectedLayer.value.height = Math.floor(
                selectedLayer.value.width / originalAspectRatio.value
              );
            } else if (changedDimension === "height") {
              selectedLayer.value.width = Math.floor(
                selectedLayer.value.height * originalAspectRatio.value
              );
            }
          };

          const inputs = reactive(
            (() => {
              const { meta } = piper;
              const inputs = {};
              for (const [key, input] of Object.entries(meta.node.inputs)) {
                const value = piper.inputs[key];
                if (!!value && ["string", "image"].includes(input.type)) {
                  inputs[key] = piper.inputs[key];
                }
              }
              return inputs;
            })()
          );

          const config = reactive(
            await (async () => {
              const { meta, inputs } = piper;
              const config = JSON.parse(inputs.config);
              for (const [key, value] of Object.entries(meta.node.inputs)) {
                if (!!config.layers[key]) {
                  continue;
                }
                switch (value.type) {
                  case "string":
                    config.layers[key] = {
                      type: "text",
                      x: 0,
                      y: 0,
                      fontSize: 24,
                      color: "#000000",
                      fontFamily: "Arial, sans-serif",
                      fontWeight: "normal",
                      backgroundColor: "transparent",
                      order: 0,
                    };
                    break;
                  case "image":
                    const url = piper.inputs[key];
                    const { width, height } = await loadImage(url);
                    config.layers[key] = {
                      type: "image",
                      x: 50,
                      y: 50,
                      width,
                      height,
                      order: 0,
                    };
                    break;
                }
              }
              return config;
            })()
          );

          const canvasWidth = ref(config.canvas.width);
          const canvasHeight = ref(config.canvas.height);
          const layers = reactive(config.layers);

          const saveConfig = () => {
            const config = JSON.stringify(
              {
                canvas: {
                  width: canvasWidth.value,
                  height: canvasHeight.value,
                },
                layers,
              },
              null,
              "\t"
            );
            piper.save({ config });
          };

          watch([canvasWidth, canvasHeight, layers], saveConfig, {
            deep: true,
          });

          const startGuideResize = (event) => {
            const onMouseMove = (e) => {
              const rect = canvas.value.getBoundingClientRect();
              const newWidth = Math.max(
                200,
                Math.min(e.clientX - rect.left, window.innerWidth - 50)
              );
              canvasWidth.value = newWidth;
            };

            const onMouseUp = () => {
              document.removeEventListener("mousemove", onMouseMove);
              document.removeEventListener("mouseup", onMouseUp);
            };

            document.addEventListener("mousemove", onMouseMove);
            document.addEventListener("mouseup", onMouseUp);
          };

          const startHorizontalGuideResize = (event) => {
            const onMouseMove = (e) => {
              const rect = canvas.value.getBoundingClientRect();
              const newHeight = Math.max(200, e.clientY - rect.top);
              canvasHeight.value = newHeight;
            };

            const onMouseUp = () => {
              document.removeEventListener("mousemove", onMouseMove);
              document.removeEventListener("mouseup", onMouseUp);
            };

            document.addEventListener("mousemove", onMouseMove);
            document.addEventListener("mouseup", onMouseUp);
          };

          const startDrag = (event, layerId) => {
            isDragging.value = true;
            dragIndex.value = layerId;
            selectedLayer.value = layers[layerId];

            // Store original aspect ratio when selecting an image layer
            if (selectedLayer.value.type === "image") {
              originalAspectRatio.value =
                selectedLayer.value.width / selectedLayer.value.height;
            }

            const rect = canvas.value.getBoundingClientRect();
            dragOffset.x = event.clientX - rect.left - layers[layerId].x;
            dragOffset.y = event.clientY - rect.top - layers[layerId].y;

            document.addEventListener("mousemove", onMouseMove);
            document.addEventListener("mouseup", stopDrag);
          };

          const startResize = (event, layerId) => {
            isResizing.value = true;
            resizeIndex.value = layerId;

            const rect = canvas.value.getBoundingClientRect();
            resizeStart.x = event.clientX - rect.left;
            resizeStart.y = event.clientY - rect.top;
            resizeStart.width = layers[layerId].width;
            resizeStart.height = layers[layerId].height;

            document.addEventListener("mousemove", onResizeMove);
            document.addEventListener("mouseup", stopResize);
          };

          const onMouseMove = (event) => {
            if (isDragging.value) {
              const rect = canvas.value.getBoundingClientRect();
              const newX = Math.floor(event.clientX - rect.left - dragOffset.x);
              const newY = Math.floor(event.clientY - rect.top - dragOffset.y);

              const layer = layers[dragIndex.value];

              // No limitations - layers can be moved anywhere
              layer.x = newX;
              layer.y = newY;
            }
          };

          const onResizeMove = (event) => {
            if (!isResizing.value) return;

            const rect = canvas.value.getBoundingClientRect();
            const currentX = event.clientX - rect.left;
            const currentY = event.clientY - rect.top;

            const layer = layers[resizeIndex.value];

            if (layer.type === "image") {
              const aspectRatio = resizeStart.width / resizeStart.height;
              const deltaX = currentX - resizeStart.x;
              const deltaY = currentY - resizeStart.y;
              const delta = Math.max(deltaX, deltaY);

              const newWidth = Math.max(10, Math.floor(resizeStart.width + delta));
              const newHeight = Math.max(10, Math.floor(newWidth / aspectRatio));

              // No limitations - can resize to any size
              layer.width = newWidth;
              layer.height = newHeight;
            }
          };

          const stopDrag = () => {
            isDragging.value = false;
            dragIndex.value = -1;
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", stopDrag);
          };

          const stopResize = () => {
            isResizing.value = false;
            resizeIndex.value = -1;
            document.removeEventListener("mousemove", onResizeMove);
            document.removeEventListener("mouseup", stopResize);
          };

          const selectLayer = (index) => {
            selectedLayer.value = layers[index];
          };

          return {
            DEBUG,
            canvas,
            inputs,
            layers,
            selectedLayer,
            isDragging,
            dragIndex,
            canvasWidth,
            canvasHeight,
            maintainAspect,
            maintainAspectRatio,
            startDrag,
            startResize,
            startGuideResize,
            startHorizontalGuideResize,
            selectLayer,
          };
        },
      });

      createApp({
        components: { App },
      }).mount(piper.appRoot.querySelector('#app'));
    </script>
  </body>
</html>
